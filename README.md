# grim-lang

![Python application](https://github.com/nananapo/grim-lang/workflows/Python%20application/badge.svg)

ほぼ確実レポート用。これで使わなかったら萎

2020/11/15より作成

## TODO

- [ ] 配列 ex. array[index]
- [ ] 名前型の演算


## What's grim-lang



プログラムは上から実行されます。

この文章も上から読んでください



#### 文字列

grimは、"か'で囲まれた部分を文字列と認識します。

> "Hello World!"



文字列の途中での改行も可能です。

>"
>
>1
>
>2
>
>3
>
>ダー！
>
>"



文字列中に、文字列の開始記号を含めるには、\を利用します。

> " \\"で文字を囲んだらコメントになります "



改行のための制御文字を表す記号はありません。



#### 数値

プログラム中に入力された数字は、同名の関数や変数が無い場合には数値として扱われます。(詳細は後述)

> 100000

#TODO 明示的な数値の宣言,キャスト



#### 入出力

標準入出力を行う関数が用意されています。

* input
* output



#### 演算子の欠如

この言語には、 =+-*/ などの一般的な演算子は全く定義されていません。(詳細は後述します)

その代わりに、同等の機能を持つ以下の関数が用意されています。

- __assign
- __plus
- __minus
- __mul
- __div



#TODO 比較記号



#### 関数の呼び方

関数を呼ぶには、関数の名前を記述します。

> 関数名()

引数が無い場合は、括弧を省略することができます。

関数名と括弧の間にスペースを入れることはできません



##### 引数の指定

> 関数名(引数1 引数2 引数3)

引数を区切るために,をつけたりする必要はありません。(詳細は後述します)



#### 関数の定義

grimでは、3種類の関数を定義することができます。

- fun
- op1
- op2



最初にfunで定義できる通常の関数について説明します。



関数の定義方法

> fun 名前(引数1 引数2 引数3...)
>
> 処理
>
> end



なお、引数が無い場合は、括弧を省略できます。

> fun 名前
>
> 処理
>
> end

引数がある場合は、名前の直後に括弧を記述する必要があります。



また、可読性を考慮しないならば、以下のように書くことも可能です。

> fun 名前 処理 end

ただし、funと名前、処理、endの間にはスペースが必要です。



##### 値を返す

関数内でreturn関数を実行することによって、処理をそこで終了することができます。

> fun test
>
> ​	処理1
>
> ​	return
>
> ​	実行されない処理
>
> end

return関数に引数を指定することによって値を返すことができます。

引数は何個でも入れられますが、返されるのは最初の値のみです(引数での計算は実行されます)。



return関数を使わずに最後まで到達した場合、最後の処理の結果が返されます。

> fun test
>
> ​	__plus(1 2)
>
> end

上の場合、__plus(1 2)の値3が返ります。



処理が無い場合はVariableNoneという特別なものが返されます。(詳細は後述)

よって、全ての関数は何らかの値を返します。



##### 関数の定義とプログラムの実行

プログラムは上から実行されますが、関数の定義はそれより先に行われます。

> test
>
> fun test
>
> ​	print("test is here")
>
> end

上の場合、testが見つからないエラーは起こりません。



##### 関数の中に関数を定義する

関数の中に関数を定義することができます。

> parent
>
> fun parent
>
> ​	sub1
>
> ​	sub2
>
> ​	fun sub1
>
> ​		print("sub1")
>
> ​	end
>
> ​	fun sub2
>
> ​		print("sub2")
>
> ​	end
>
> end

上の場合、parentが実行され、sub1、sub2が実行されます。



ただし、OOPの言語によく見られるような表記

> parent.sub または parent->sub

はできないことに注意してください。



内部的には、今まで書いてきたプログラム自体がmain関数(呼ぶことはできない)の中に記述されているように扱われています。



### 演算子の定義

grimでは演算子が全く定義されていませんが、新しく関数として定義することができます。



#TODO 優先度



##### 演算子の種類

演算子は2種類あります。

* 前置

* 中置



前置演算子は、

> 演算子 右辺

とあったときに、右辺の値を受け取って1つの値を返す関数です。



中置演算子は、

> 左辺 演算子 右辺

とあったときに、左辺と右値を受け取って1つの値を返す関数です。



##### 演算子関数の定義



前置演算子は次のように定義できます。

> op1 演算子名(引数1)
>
> ​	処理
>
> end

##### 

中置演算子は次のように定義できます。

> op2 演算子名(引数1 引数2)
>
> ​	処理
>
> end



##### 演算子の利用

> op2 tasu(v1 v2)
>
> ​	__plus(v1 v2)
>
> end
>
> print(1 tasu 2)

上では、2つの値を足す"tasu"という名前の演算子を定義しています。



printの中で、

> 1 tasu 2

という様に記述していますが、これは

> tasu(1 2)

と等価です。



#### 文の区切れ

grimでは、funやend、引数を指定する括弧以外に文(処理)を分割する記号はありません。

grimの処理系では、演算子によってプログラムを解釈しています。



> 以後、+は中置、!は前置演算子
>
> A + B C + D

この場合、A+BとC+Dの間にそれを結ぶ演算子が無いため、二つの独立した処理として扱っています。



> A + B ! C+D

この場合、A+BとC+Dの間に!演算子がありますが、!演算子は右の値と結合するので、二つの独立した処理として扱います。



関数を呼ぶときの引数の区切れも同じ原理で分割し、前から順に引数に割り当てています。



**全ての処理は、演算子とその対象の間にスペースを空ける必要があります。**

>A*B 

これは、AとBの間に中置演算子があるように見えますが、grimではA*Bという名前の変数の参照/引数なし関数の呼び出しとして扱われます。



#### 変数

変数は、値の入った名前がある箱です。



##### 代入可能な値

変数には以下のものを代入できます

* 文字列型
* 数値型
* VariableNone型
* 名前型
* 不定型



#TODO 配列



##### 文字列型

上記の、"か'で文章を囲むことによって実現できるものです。



##### 数値型

これも既に記されています。



##### VariableNone型

関数が値を返さない場合にのみ使用される特別な型です。直接指定することはできません。

なにもないことを示します。



#### 変数の定義

名前型と不定型を説明する前に、変数の定義方法を説明します。

grimには変数の宣言をするキーワードや演算子が無いため、その代わりに関数を使います。

> __assign(変数名 値)

変数名には、直接名前を入力するか、名前型の変数を使います。

**__assign関数は値を返しません。(VariableNone型を返します)**



##### 名前型

名前型は、値ではなく名前を持ちます。

上記の__assignでは、名前型の値が入った変数を1つめの引数に指定することで、名前型が保存している名前の変数名に、引数2の値を割り当てます。



関数を定義するときに引数名の頭に;をつけることで、名前型の値を受け取るような引数を明示的に作ることができます。

> op2 =(;target value)
>
> ​	__assign(target value)
>
> ​	value
>
> end

上では、左辺の名前に右辺の値を割り当てるような中置演算子=を定義しています。また、演算の結果としては、valueを返しています。

ここから下のプログラム例では、上記の=演算子を利用します。



実際に=を使ってみると、

> aisatu = "Hello World"

この場合、nameにはaisatuという名前を持った名前型の値が入ります。

valueには"Hello World"という文字列型が入っているので、__assignによってaisatuに文字列が代入されます。



一つ目の引数は;nameと指定されていますが、これは;nameという名前の変数ではなくnameという名前の変数になることに注意してください。



次に、変数はどのスコープで名前を束縛されるかについて説明します。



#### スコープ

grimでは、基本的に静的スコープを採用しています。



> name = "John"
>
> fun who
>
> ​	print(name)
>
> end

この場合、whoを実行すると、その上位の関数mainに定義されたnameを参照し、Johnと表示します。



##### 動的スコープの明示

変数を参照するとき、変数名の頭に:をつけることによって動的スコープを利用することができます。

> fun sub1
>
> ​	print(:name)
>
> end
>
> fun sub2
>
> ​	name = "John"
>
> ​	sub1
>
> end

この場合、sub1を実行するとnameが見つからずエラーが出ますが、sub2を実行するとJohnと表示されます。



##### 変数,関数の捜索順序

引数が無い関数の呼び出しと、変数の参照は見分けがつきません。システムは、変数、関数の順に検索します。

名前が関数であることが明示されている場合、関数のみをスコープの設定に応じて検索します。



引数が無い関数の呼び出しの後ろに括弧を書くことで、それが関数の呼び出しであることを明示することができます。

> fun test
>
> end
>
> test()



変数と関数が見つからなかった場合、ビルトイン関数、数値の順に確認します。それでも分からなかった場合は見つからなかったと結論を出します。



##### 名前型の演算

名前型は、__assignの引数として利用される以外にも使い道があります。

> fun test(va1 va2 ;lambda)
>
> ​	print(lambda(va1 va2))
>
> end
>
> fun +(va1 va2)
>
> ​	__plus(va1 va2)
>
> end
>
> test(1 2 +)

名前型の演算は、名前を参照します。上の場合、3と表示されます。



#TODO



##### 不定型

この型は、変数が見つからないときに一時的に利用されます。演算はできません。



> name = 3

上の場合、=の一つ目の引数に指定された変数nameは、まだどこにも定義されていません。

しかし、システムは変数が見つからなくてもすぐにエラーを出すことはなく、name=3が書かれているスコープで、nameを不定型に束縛します。

=の引数に値を渡すときに、不定型のnameは不定型ではなく、名前がnameな名前型を渡します。

1処理の終了時に不定型が残っている場合、エラーを出します。



#### 処理順序

#TODO

関数 → 演算子(優先度順)

#### 制御構文

#TODO



#### コメント

プログラム中にコメントを書くための文字はありません。

ただし、次のように自分で似たものを作ることができます。

> op1 #(value)
>
> "#でコメント"
>
> end
>
> 処理 # "コメント" 処理